`timescale 1ns / 1ps

module router_register(
    // Inputs from other modules
    input clk,
    input resetn,
    input packet_valid,
    input [7:0] datain,
    input fifo_full,
    // Control signals from the FSM
    input detect_add,
    input ld_state,
    input laf_state,
    input full_state,
    input lfd_state,
    input rst_int_reg,
    // Outputs generated by this module
    output reg err,
    output reg parity_done,
    output reg low_packet_valid,
    output reg [7:0] dout
);

    // This register latches the header byte when detect_add is high.
    // It holds the header until the FSM is ready to load it (lfd_state).
    reg [7:0] hold_header_byte;

    // This register saves a data byte if it arrives while the FIFO is full.
    // It holds the byte until the FSM enters the 'load_after_full' state.
    reg [7:0] fifo_full_state_byte;

    // This register calculates the running parity by XORing all packet bytes.
    // It's the router's own calculation of what the parity SHOULD be.
    reg [7:0] internal_parity;

    // This register stores the final parity byte that comes with the packet.
    // This is the "expected" parity sent by the transmitter.
    reg [7:0] packet_parity_byte;


    // This block determines what data is sent to the FIFO's input.
    // It follows a clear priority based on the FSM's state.
    always@(posedge clk)
    begin
        if(!resetn)
            dout <= 8'b0;
        else
        begin
            // PRIORITY 1: Latch the header byte into our internal register.
            // This happens first when a new packet is detected.
            if(detect_add && packet_valid)
                hold_header_byte <= datain;

            // PRIORITY 2: Output the stored header to the FIFO.
            // The FSM is now in lfd_state, asking for the header.
            else if(lfd_state)
                dout <= hold_header_byte;

            // PRIORITY 3: Handle normal payload data.
            else if(ld_state && !fifo_full)
                dout <= datain; // Pass input directly to output.

            // PRIORITY 4: Handle the "FIFO is full" condition.
            // We can't send to the FIFO, so we save the byte internally.
            else if(ld_state && fifo_full)
                fifo_full_state_byte <= datain;

            // PRIORITY 5: Handle the "load after full" condition.
            // The FIFO has space again. Send the byte we saved.
            else if(laf_state)
                dout <= fifo_full_state_byte;
        end
    end



    // This block runs in parallel, calculating the packet's parity.
    always@(posedge clk)
    begin
        if(!resetn)
            internal_parity <= 8'b0;

        // When a new packet is detected, reset the parity calculator to zero.
        else if (detect_add)
            internal_parity <= 8'b0;

        // Include the header byte in the parity calculation.
        // This is the first XOR operation for the packet.
        else if(lfd_state)
            internal_parity <= internal_parity ^ hold_header_byte;

        // For every subsequent payload byte, XOR it with the running total.
        // We check 'full_state' to ensure we don't double-count the byte
        // that was saved during the FIFO full condition.
        else if(ld_state && packet_valid && !full_state)
            internal_parity <= internal_parity ^ datain;
    end


    // This block's only job is to catch and store the parity byte that
    // comes at the very end of the packet from the transmitter.
    always@(posedge clk)
    begin
        if(!resetn)
            packet_parity_byte <= 8'b0;
        else
        begin
            // The condition for identifying the parity byte is when we are in the
            // 'load_data' state BUT the 'packet_valid' signal has just gone low.
            if(!packet_valid && ld_state)
                packet_parity_byte <= datain;
        end
    end


    // These blocks generate status signals for the FSM to use.

    // This logic determines when the packet is considered "done".
    always@(posedge clk)
    begin
        if(!resetn)
            parity_done <= 1'b0;
        else
        begin
            // The packet is done if we are loading data and packet_valid goes low.
            if(ld_state && !fifo_full && !packet_valid)
                parity_done <= 1'b1;
            // It's also done if we were stalled, and now we are loading the parity.
            else if(laf_state && low_packet_valid && !parity_done)
                parity_done <= 1'b1;
            // Reset for the next packet.
            else if(detect_add)
                parity_done <= 1'b0;
        end
    end

    // This is a helper signal that "remembers" that packet_valid has gone low.
    // It helps the FSM make decisions in the 'load_after_full' state.
    always@(posedge clk)
    begin
        if(!resetn)
            low_packet_valid <= 1'b0;
        else
        begin
            // When the FSM tells us to reset, we do.
            if(rst_int_reg)
                low_packet_valid <= 1'b0;
            // Latch that the packet is ending.
            if(ld_state == 1'b1 && packet_valid == 1'b0)
                low_packet_valid <= 1'b1;
        end
    end


    // This block compares the calculated parity with the expected parity.
    always@(posedge clk)
    begin
        if(!resetn)
            err <= 1'b0;
        else
        begin
            // Only check for an error AFTER the whole packet has been received.
            if(parity_done)
            begin
                // If the calculated parity doesn't match the packet's parity, flag an error.
                if(internal_parity != packet_parity_byte)
                    err <= 1'b1;
                else
                    err <= 1'b0; // Otherwise, clear the error flag.
            end
        end
    end

endmodule

